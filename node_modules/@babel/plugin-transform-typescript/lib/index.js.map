{"version":3,"names":["_helperPluginUtils","require","_pluginSyntaxTypescript","_helperCreateClassFeaturesPlugin","_constEnum","_enum","_namespace","isInType","path","parent","type","parentPath","findParent","exportKind","GLOBAL_TYPES","WeakMap","NEEDS_EXPLICIT_ESM","PARSED_PARAMS","WeakSet","isGlobalType","scope","name","hasBinding","get","has","console","warn","registerGlobalType","programScope","add","safeRemove","ids","getBindingIdentifiers","Object","keys","binding","getBinding","identifier","removeBinding","opts","noScope","remove","_default","declare","api","types","t","template","assertVersion","JSX_PRAGMA_REGEX","allowNamespaces","jsxPragma","jsxPragmaFrag","onlyRemoveTypeImports","optimizeConstEnums","allowDeclareFields","classMemberVisitors","field","node","buildCodeFrameError","value","decorators","definite","isClassPrivateProperty","abstract","accessibility","readonly","optional","typeAnnotation","override","method","constructor","classPath","assigns","paramPath","param","parameter","id","isIdentifier","isAssignmentPattern","left","push","statement","ast","cloneNode","replaceWith","registerBinding","injectInitialization","inherits","syntaxTypeScript","visitor","Pattern","visitPattern","Identifier","RestElement","Program","enter","state","file","fileJsxPragma","fileJsxPragmaFrag","set","Set","comments","comment","jsxMatches","exec","pragmaImportName","split","pragmaFragImportName","stmt","isImportDeclaration","program","importKind","specifier","specifiers","local","importsToRemove","specifiersLength","length","isAllSpecifiersElided","size","isImportTypeOnly","programPath","importPath","isExportDeclaration","isVariableDeclaration","isTSTypeAliasDeclaration","isTSDeclareFunction","isTSInterfaceDeclaration","isClassDeclaration","isTSEnumDeclaration","isTSModuleDeclaration","exit","sourceType","pushContainer","exportNamedDeclaration","ExportNamedDeclaration","source","every","isExportSpecifier","ExportAllDeclaration","ExportSpecifier","ExportDefaultDeclaration","declaration","TSDeclareFunction","TSDeclareMethod","VariableDeclaration","VariableDeclarator","TSIndexSignature","ClassDeclaration","Class","typeParameters","superTypeParameters","implements","forEach","child","isClassMethod","isClassPrivateMethod","kind","isClassProperty","isClassAccessorProperty","Function","returnType","params","shift","TSModuleDeclaration","transpileNamespace","TSInterfaceDeclaration","TSTypeAliasDeclaration","TSEnumDeclaration","const","transpileConstEnum","transpileEnum","TSImportEqualsDeclaration","isTSExternalModuleReference","moduleReference","expression","variableDeclaration","variableDeclarator","entityNameToExpr","registerDeclaration","TSExportAssignment","TSTypeAssertion","tsSatisfiesExpression","isTSAsExpression","isTSSatisfiesExpression","tsInstantiationExpression","CallExpression","OptionalCallExpression","NewExpression","JSXOpeningElement","TaggedTemplateExpression","isTSQualifiedName","memberExpression","right","referencePaths","sourceFileHasJsx","traverse","JSXElement|JSXFragment","stop","exports","default"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxTypeScript from \"@babel/plugin-syntax-typescript\";\nimport type { types as t } from \"@babel/core\";\nimport { injectInitialization } from \"@babel/helper-create-class-features-plugin\";\nimport type { Binding, NodePath, Scope } from \"@babel/traverse\";\nimport type { Options as SyntaxOptions } from \"@babel/plugin-syntax-typescript\";\n\nimport transpileConstEnum from \"./const-enum\";\nimport type { NodePathConstEnum } from \"./const-enum\";\nimport transpileEnum from \"./enum\";\nimport transpileNamespace from \"./namespace\";\n\nfunction isInType(path: NodePath) {\n  switch (path.parent.type) {\n    case \"TSTypeReference\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSTypeQuery\":\n      return true;\n    case \"TSQualifiedName\":\n      return (\n        // `import foo = ns.bar` is transformed to `var foo = ns.bar` and should not be removed\n        path.parentPath.findParent(path => path.type !== \"TSQualifiedName\")\n          .type !== \"TSImportEqualsDeclaration\"\n      );\n    case \"ExportSpecifier\":\n      return (\n        // export { type foo };\n        path.parent.exportKind === \"type\" ||\n        // export type { foo };\n        // @ts-expect-error: DeclareExportDeclaration does not have `exportKind`\n        (path.parentPath as NodePath<t.ExportSpecifier>).parent.exportKind ===\n          \"type\"\n      );\n    default:\n      return false;\n  }\n}\n\nconst GLOBAL_TYPES = new WeakMap<Scope, Set<string>>();\n// Track programs which contain imports/exports of values, so that we can include\n// empty exports for programs that do not, but were parsed as modules. This allows\n// tools to infer unambiguously that results are ESM.\nconst NEEDS_EXPLICIT_ESM = new WeakMap();\nconst PARSED_PARAMS = new WeakSet();\n\nfunction isGlobalType({ scope }: NodePath, name: string) {\n  if (scope.hasBinding(name)) return false;\n  if (GLOBAL_TYPES.get(scope).has(name)) return true;\n\n  console.warn(\n    `The exported identifier \"${name}\" is not declared in Babel's scope tracker\\n` +\n      `as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\\n` +\n      `never encountered it as a TypeScript type declaration.\\n` +\n      `It will be treated as a JavaScript value.\\n\\n` +\n      `This problem is likely caused by another plugin injecting\\n` +\n      `\"${name}\" without registering it in the scope tracker. If you are the author\\n` +\n      ` of that plugin, please use \"scope.registerDeclaration(declarationPath)\".`,\n  );\n\n  return false;\n}\n\nfunction registerGlobalType(programScope: Scope, name: string) {\n  GLOBAL_TYPES.get(programScope).add(name);\n}\n\n// A hack to avoid removing the impl Binding when we remove the declare NodePath\nfunction safeRemove(path: NodePath) {\n  const ids = path.getBindingIdentifiers();\n  for (const name of Object.keys(ids)) {\n    const binding = path.scope.getBinding(name);\n    if (binding && binding.identifier === ids[name]) {\n      binding.scope.removeBinding(name);\n    }\n  }\n  path.opts.noScope = true;\n  path.remove();\n  path.opts.noScope = false;\n}\n\nexport interface Options extends SyntaxOptions {\n  /** @default true */\n  allowNamespaces?: boolean;\n  /** @default \"React.createElement\" */\n  jsxPragma?: string;\n  /** @default \"React.Fragment\" */\n  jsxPragmaFrag?: string;\n  onlyRemoveTypeImports?: boolean;\n  optimizeConstEnums?: boolean;\n  allowDeclareFields?: boolean;\n}\n\ntype ExtraNodeProps = {\n  declare?: unknown;\n  accessibility?: unknown;\n  abstract?: unknown;\n  optional?: unknown;\n  override?: unknown;\n};\n\nexport default declare((api, opts: Options) => {\n  // `@babel/core` and `@babel/types` are bundled in some downstream libraries.\n  // Ref: https://github.com/babel/babel/issues/15089\n  const { types: t, template } = api;\n\n  api.assertVersion(7);\n\n  const JSX_PRAGMA_REGEX = /\\*?\\s*@jsx((?:Frag)?)\\s+([^\\s]+)/;\n\n  const {\n    allowNamespaces = true,\n    jsxPragma = \"React.createElement\",\n    jsxPragmaFrag = \"React.Fragment\",\n    onlyRemoveTypeImports = false,\n    optimizeConstEnums = false,\n  } = opts;\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // eslint-disable-next-line no-var\n    var { allowDeclareFields = false } = opts;\n  }\n\n  const classMemberVisitors = {\n    field(\n      path: NodePath<\n        (t.ClassPrivateProperty | t.ClassProperty | t.ClassAccessorProperty) 